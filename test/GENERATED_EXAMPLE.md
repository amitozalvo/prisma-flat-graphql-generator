# Generated GraphQL Example

This shows the actual output generated by the Prisma GraphQL Generator.

## Input: Prisma Schema

```prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  password  String   // Excluded from GraphQL
  posts     Post[]
  createdAt DateTime @default(now())
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
}

// Generator config
generator graphql {
  provider = "..."
  excludeOutputFields = ["password"]
}
```

## Output: Generated GraphQL

### User Type (`generated/graphql/User/typeDefs.ts`)

```graphql
type User {
  id: Int!
  email: String!
  name: String
  createdAt: DateTime!
  # password excluded âœ“
  posts(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum]
  ): [Post!]!
  _count: UserCountOutputType!
}

type Query {
  user(
    where: UserWhereInput
    orderBy: [UserOrderByWithRelationInput]
    cursor: UserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserScalarFieldEnum]
  ): User

  users(
    where: UserWhereInput
    orderBy: [UserOrderByWithRelationInput]
    cursor: UserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserScalarFieldEnum]
  ): [User!]!
}
```

### Resolvers (`generated/graphql/User/resolvers.ts`)

```typescript
const USER_FIELDS = {
  id: { kind: 'scalar', type: 'Int', isList: false },
  email: { kind: 'scalar', type: 'String', isList: false },
  name: { kind: 'scalar', type: 'String', isList: false },
  createdAt: { kind: 'scalar', type: 'DateTime', isList: false },
  posts: { kind: 'object', type: 'Post', isList: true }
};

function buildPrismaSelect(info: any, modelFields: any): any {
  if (!info?.fieldNodes?.[0]?.selectionSet) {
    return {};
  }

  const selections = info.fieldNodes[0].selectionSet.selections;
  const select: any = {};

  for (const selection of selections) {
    if (selection.kind !== 'Field') continue;

    const fieldName = selection.name.value;

    // Skip GraphQL meta fields
    if (fieldName.startsWith('__')) continue;

    const fieldInfo = modelFields[fieldName];

    if (!fieldInfo) continue;

    if (fieldInfo.kind === 'object') {
      // Relation field - add to select with nested selection
      if (selection.selectionSet) {
        select[fieldName] = buildNestedSelect(selection.selectionSet);
      } else {
        select[fieldName] = true;
      }
    } else {
      // Scalar/enum field - add to select
      select[fieldName] = true;
    }
  }

  return Object.keys(select).length > 0 ? { select } : {};
}

function buildNestedSelect(selectionSet: any): any {
  const select: any = {};

  for (const selection of selectionSet.selections) {
    if (selection.kind !== 'Field') continue;
    const fieldName = selection.name.value;

    // Skip GraphQL meta fields
    if (fieldName.startsWith('__')) continue;

    select[fieldName] = true;
  }

  return Object.keys(select).length > 0 ? { select } : true;
}

export default {
  Query: {
    user: (_parent: any, args: any, context: any, info: any) => {
      const prismaSelect = buildPrismaSelect(info, USER_FIELDS);
      return context.prisma.User.findFirst({ ...args, ...prismaSelect });
    },
    users: (_parent: any, args: any, context: any, info: any) => {
      const prismaSelect = buildPrismaSelect(info, USER_FIELDS);
      return context.prisma.User.findMany({ ...args, ...prismaSelect });
    },
  },
};
```

**Note**: Each resolver file is completely self-contained with its own field metadata and optimization utilities. No external dependencies needed!

### Input Types (`generated/graphql/inputTypes.ts`)

```graphql
input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IntFilter
  email: StringFilter
  name: StringNullableFilter
  # password excluded from filters âœ“
  createdAt: DateTimeFilter
  posts: PostListRelationFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

# ... more filter types
```

## Usage Example

```typescript
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import { PrismaClient } from '@prisma/client';
import { typeDefs, resolvers } from './generated/graphql';

const prisma = new PrismaClient();

// No middleware needed - resolvers include built-in optimization!
const server = new ApolloServer({
  typeDefs,
  resolvers,
});

const { url } = await startStandaloneServer(server, {
  context: async () => ({ prisma }),
  listen: { port: 4000 },
});

console.log(`ðŸš€ Server ready at ${url}`);

// Query examples:
// - users { id, email, name }  // Only fetches selected fields
// - user(where: { email: { equals: "alice@example.com" } }) { name, posts { title } }  // Optimized with include
// - users(where: { posts: { some: { published: { equals: true } } } }) { name }  // No N+1 issues
```

## Key Features Demonstrated

âœ… **Zero Dependencies**: No @paljs or graphql-type-json needed
âœ… **Built-in Optimization**: Automatic N+1 prevention without middleware
âœ… **Type Generation**: Complete GraphQL types from Prisma models
âœ… **Query Generation**: findFirst and findMany for each model
âœ… **Filter Support**: Full Prisma where/orderBy/cursor/pagination
âœ… **Relations**: Nested queries with arguments
âœ… **Field Exclusions**: Sensitive fields hidden from GraphQL
âœ… **Input Types**: All Prisma filters available in GraphQL
âœ… **Type Safety**: Generated TypeScript resolvers
âœ… **Self-Contained**: Each resolver file includes its own utilities
